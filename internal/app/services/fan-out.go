package services

import (
	"context"
)

// Важная информация о стратегии определения оптимального кол-ва воркеров и конструкций вида:
//     workersCount = runtime.NumCPU()
//
// Вызов runtime.NumCPU() _не всегда_ возвращает кол-во ядер процессора доступное приложению.
// Пример: в среде k8s runtime.NumCPU() возвращает кол-во ядер всей ноды.
// При этом, приложению может быть доступно значительно меньшее кол-во ядер.
// В этом случае, возможна деградация производительности, вместо ее увеличения.
//
// Возможный вариант решения:
// https://github.com/uber-go/automaxprocs
// который автоматически устанавливает GOMAXPROCS в соответствии
//с квотой ядер реально доступных для приложения.
//
// В нашем случае воркеры реализованы исключительно в учебных целях.
// Поэтому мы будем использовать константу :-)

var batchWorkerCount = 8

// fanOut - демультиплексор каналов.
// Распределяет значения из inputCh в несколько выходных каналов (round-robin).
// Количество выходных каналов задается batchWorkerCount.
// Если контекст завершится раньше, чем закончатся значения во входном канале,
// то закроет все выходные каналы и завершит выполнение.
func fanOut(ctx context.Context, inputCh chan string) []chan string {
	// Создаем слайс выходных каналов
	outChans := make([]chan string, batchWorkerCount)
	for i := 0; i < batchWorkerCount; i++ {
		outChans[i] = make(chan string)
	}

	// Горутина, которая считывает значения из входного канала и передает их в каналы поочередно (round-robin).
	go func() {
		// Закрываем все выходные каналы при выходе из горутины
		defer func(outChans []chan string) {
			for _, ch := range outChans {
				close(ch)
			}
		}(outChans)

		// Считываем значения из входного канала
		for i := 0; ; i++ {
			select {
			// Если контекст завершился, завершаем горутину
			case <-ctx.Done():
				return
			case item, ok := <-inputCh:
				// Если входной канал закрыт, завершаем горутину
				if !ok {
					return
				}
				// Если канал не закрыт, отправляем значение в очередной выходной канал
				n := i % batchWorkerCount
				outChans[n] <- item
			}
		}
	}()

	return outChans
}
